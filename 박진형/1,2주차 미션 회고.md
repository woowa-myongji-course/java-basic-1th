## 계산기 미션 회고

단위 테스트를 위한 JUnit과 AssertJ에 대해 잘 모른 상태로 투입된 서비스에서 그저 이전에 작성된 테스트코드 형태 그대로 작성하기 바빴습니다. 그렇게 하다보니 테스트코드는 당연히 ‘모든 예외처리에 대한 테스트와 성공 테스트 하나’ 라는 공식이 머릿속에 있었습니다. 하지만 이번 계산기 미션을 하며 JUnit의 구성과 주요 문법을 배울 수 있었습니다. 특히 여러 값들에 대한 테스트를 따로 진행하지 않고 `@ParameterizedTest` 를 통해 수행할 수 있음을 배웠습니다.

더 나아가 기존에 제시한 JUnit 테스트 코드를 AssertJ로 리팩터링하면서 특정 예외가 발생하는지와 예외 메세지의 값을 함께 검증하는 `assertThatThrownBy` 에 대해 경험할 수 있었습니다.

특히 Given-When-Then 패턴과 D-C-I 패턴을 통한 구조화된 테스트코드 작성 방법을 익힐 수 있었습니다.

- Given-When-Then 패턴
    - **Given:** 테스트를 위해 필요한 **준비물(상태, 데이터)**을 세팅하는 단계.
    - **When:** 실제로 **검증하고자 하는 메서드**를 호출하는 단계.
    - **Then:** 호출 결과가 **기대한 대로 나왔는지 확인(AssertJ)**하는 단계.
- D-C-I 패턴
    - **Describe (D):** 테스트 대상 (클래스나 메서드 이름)
    - **Context (C):** 테스트 상황 (어떤 조건이 주어졌는가)
    - **It (I):** 결과 (그래서 무엇을 반환하거나 행하는가)

기존에는 메서드 하나로부터 예외처리 수 +1의 테스트코드를 기계처럼 작성해왔다면, 이제는 사용자 입장에서 실수할 수 있는 부분에 대해 미리 제어를 하며 이를 검증하기 위한 테스트코드를 작성할 수 있게 되었습니다.

## **자동차 경주 미션 회고**

자동차 경주 미션을 진행하며 내가 배워온 자바 객체지향에 대한 기초지식을 아는 것과 적용할줄 아는 것의 차이를 많이 느꼈습니다. 특히 생성자에 로직을 넣거나 필드가 없이 메서드만 있는 객체?에 대한 생성자를 private으로 숨기지 않는 등의 실수를 반복하였습니다.

저의 반복되는 실수에 멘토님께서는 내가 생각하는 객체란 무엇인지에 대한 원초적 질문을 던져주셨고 저는 다음과 같이 답했습니다.

“객체는 상태(필드)와 행위(메서드)를 함께 가진 것이라고 생각한다. 행위를 가졌기에 객체라면 객체라고 할 수도 있겠지만, 처음에 Judge를 구현한 것은 그저 CarGroup이 가진 역할을 분배하기 위함이었다. 생각해보니 이또한 멘토님이 반복적으로 언급해주셨던 방법인 생성자를 private로 숨기고 내부 메서드들을 static으로 처리하는 방법이 더 나은듯하다..!”

또 변수명에는 List나 Set과 같은 타입을 적는 것은 타입이 바뀌는 것에 대해 대비하기 어렵기 때문에 지양을 한다는 것을 처음 알게 되었습니다.

특히 실제 프로젝트에서는 제미나이나 코파일럿으로 바이브코딩을 많이 하다보니 의도만 맞는 스트림을 자주 사용했습니다. 이번 스터디 미션에서는 최대한 내가 아는만큼만 해보고자 for문으로 직접 작성을 해왔지만, 멘토님이 스트림을 통해 가독성을 더 좋게 만들어보라는 피드백을 주셔서 스트림 람다 작성에 대해서도 알아보았습니다.

```java
// 리팩터링 전
private int getMaxLocation() {
    int max = 0;
    for (MovingCar car : cars) {
        max = Math.max(max, car.getLocation());
    }
    return max;
}
```

```java
// 리팩터링 후
private int getMaxLocation() {
    return movingCars.stream()
        .mapToInt(MovingCar::getLocation)
        .max()
        .orElse(0);
}
```

스트림을 통해 작성하니 가독성도 좋아지고 의도도 더 명확해졌습니다.

### 문제 해결을 위해 새로 알게된 것

1. 함수형 인터페이스

   함수형 인터페이스에 대해 알게되었습니다. 간단히 말하면 추상 메서드가 딱 하나만 존재할 수 있도록 강제한 것이며 이를 자동차의 이동 전략(4 이상인 경우 움직임)과 반복입력 로직에서 적용했습니다.

   [자동차 이동전략]

   자동차는 랜덤 결과가 4 이상인 경우 전진하지만, 이렇게되면 테스트코드에서의 자유도가 떨어집니다. 이에 인터페이스로 boolean 타입의 move()를 구현하고, 이에 대해 상속받는 메서드는 랜덤값이 4 이상인 조건을 두어 구분하였습니다.

   [반복 입력 로직]

   자동차 이름규칙 혹은 라운드 수에 대해 잘못 입력된 경우 재입력을 받는 로직이 기존에는 for문과try-catch로 각각 제어되었습니다. 이후 함수형 인터페이스의 클래스 중 Supplier<T>를 알게되었다. 이는 매개변수는 사용하되 반환값이 없습니다.

   이를 통해 성공할때까지 입력을 받는 로직을 다음과 같이 구현하였습니다.

    ```java
    		private static <T> T repeatUntilSuccess(Supplier<T> supplier) {
            while (true) {
                try {
                    return supplier.get();
                } catch (IllegalArgumentException e) {
                    System.out.println("[ERROR] " + e.getMessage());
                }
            }
        }
    
        public static CarGroup getCars() {
            return repeatUntilSuccess(() -> {
                System.out.println("경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분).");
                String input = sc.nextLine();
                List<String> names = List.of(input.split(","));
                return CarGroup.from(names);
            });
        }
    
        public static int getTryCount() {
            return repeatUntilSuccess(() -> {
                System.out.println("시도할 회수는 몇회인가요?");
                String input = sc.nextLine();
                return validateCount(input);
            });
        }
    ```

2. 원시값 포장

   자동차 이름에 대해 5자 이하라는 서비스 요구사항이 있었습니. 이에 저는 각 자동차가 필드로 가지는 String name에 대해 생성시 따로 검증하는 메서드를 구현했습니다. 하지만, 이에 대한 책임을 더 명확히 하고자 찾아보던 중 원시값 포장을 알게되었습니다. Name이라는 클래스를 따로 두어 내부적으로 검증을 하는 것입니다.

    ```java
    public class Name {
    
        private final String name;
    
        public Name(String name) {
            validate(name);
            this.name = name.trim();
        }
    
        private void validate(String name) {
            if (name == null || name.trim().isEmpty()) {
                throw new IllegalArgumentException("이름은 빈 값일 수 없습니다.");
            }
            if (name.trim().length() > 5) {
                throw new IllegalArgumentException("이름은 5자 이하만 가능합니다.");
            }
        }
    
        public String getValue() {
            return name;
        }
    
    }
    ```


### 차후 목표

로또 미션부터는 다음과 같은 원칙을 가지고 해보겠습니다.

- 코드를 작성하기에 앞서 구조를 시각화해보기
- 메서드 하나 작성 단위로 테스트코드 구현하기 (이부분 잘 안이뤄지고 있었음)
- 코드를 작성하며 이전에 받았던 피드백에 적합한지 확인하기
- 클래스는 하나의 기능만을 담당하며 책임이 많아지면 분리하기
- 메서드는 좋은 테스트코드를 작성할 수 있는 단위로 구현하기
